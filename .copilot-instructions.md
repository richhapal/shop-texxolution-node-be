# Shop Texxolution Backend Development Guidelines

> **Project:** Shop Texxolution E-commerce Platform Backend  
> **Version:** 3.0  
> **Last Updated:** November 14, 2025  
> **Base URL:** `https://shop-texxolution-node-be.onrender.com`

## üéØ Core Principles

### API Contract Compliance

- **ALWAYS** follow the official Shop Texxolution API Contract v3.0 located at `DASHBOARD_API_CONTRACT.md`
- Never deviate from documented response structures without updating the contract first
- All endpoints must match the exact HTTP methods, paths, and response formats specified
- Use staging URL `https://shop-texxolution-node-be.onrender.com` for all documentation examples

### Response Structure Standards

**ALL API responses must use this consistent JSON structure:**

```javascript
// Success Response
{
  success: true,
  message: "Operation completed successfully.",
  data: {
    // Response payload here
  }
}

// Error Response
{
  success: false,
  message: "Error description",
  errors: ["Detailed error message 1", "Detailed error message 2"]
}
```

## üîê Authentication & Authorization

### Public Endpoints (No Auth Required)

- `/health` - Health check
- `/api/public/*` - All public product and enquiry endpoints
- **NO authentication middleware** on these routes
- **NEVER expose** pricing, vendor details, or internal data

### Dashboard Endpoints (JWT Required)

- `/api/dashboard/*` - All dashboard management endpoints
- **MUST use** JWT authentication middleware
- **Role-based access control:**
  - `admin`: Full CRUD access to all resources
  - `editor`: Create, read, update access (no delete)
  - `viewer`: Read-only access

### Authentication Implementation

```javascript
// JWT middleware example
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({
      success: false,
      message: "Access token required",
    });
  }
  // ... verify token logic
};
```

## üì¶ Product Schema Guidelines

### Core Product Fields

```javascript
// Required fields (never optional)
{
  sku: String,           // Unique product identifier
  uniqueId: String,      // SEO-friendly URL identifier
  name: String,          // Product display name
  category: String,      // From predefined enum list
  description: String,   // Detailed product description
  composition: String,   // Material composition
  color: String,         // Primary color
  width: String,         // Fabric width
  gsm: Number,          // Grams per square meter
  finish: String,        // Surface finish type
  application: String,   // Use cases
  moq: Number,          // Minimum order quantity
  leadTime: String,     // Production timeline
  status: String        // active|inactive|draft|discontinued
}
```

### Dynamic Category Data

**Use `categoryData` (Schema.Types.Mixed) for category-specific fields:**

```javascript
// Example for Fabric (Finished) category
categoryData: {
  fabricType: "Woven",
  threadCount: "120x80",
  shrinkage: "3%",
  washCare: "Machine wash cold",
  organicCertified: true
}

// Example for Yarn category
categoryData: {
  type: "Combed",
  count: "40s",
  ply: "Single",
  twist: "Z-twist",
  packaging: "Cone"
}
```

### SEO-Friendly uniqueId Generation

**ALWAYS generate uniqueId using this pattern:**

```javascript
const slugify = require("slugify");

const generateUniqueId = (productName, category) => {
  const timestamp = Date.now();
  const nameSlug = slugify(productName.toLowerCase(), {
    remove: /[*+~.()'"!:@]/g,
    replacement: "-",
    strict: true,
  });
  const categorySlug = slugify(category.toLowerCase(), {
    replacement: "-",
    strict: true,
  });

  return `${nameSlug}-${categorySlug}-${timestamp}`;
};

// Example: "premium-cotton-fabric-fabric-finished-1699876543"
```

## üóÑÔ∏è Database Query Optimization

### Public Endpoints Performance

```javascript
// ALWAYS use .lean() for public GET queries
const products = await Product.find({ status: "active" })
  .select("-createdBy -updatedBy -__v") // Exclude internal fields
  .lean() // Return plain objects (faster)
  .limit(limit)
  .skip((page - 1) * limit);
```

### Field Exclusion Rules

**NEVER return these fields in public endpoints:**

- `passwordHash` (User model)
- `__v` (Mongoose version key)
- `createdBy` / `updatedBy` (in public responses)
- Any vendor or pricing information

**Dashboard endpoints should populate references:**

```javascript
// Populate user references with limited fields
.populate('createdBy updatedBy', 'name email')
```

## üîÑ Pagination Standards

**ALL paginated endpoints must return this structure:**

```javascript
{
  success: true,
  message: "Resources retrieved successfully.",
  data: {
    [resourceName]: [...], // Array of results
    pagination: {
      currentPage: 1,
      totalPages: 5,
      totalProducts: 100,      // or totalEnquiries, totalQuotations
      hasNextPage: true,
      hasPrevPage: false,
      limit: 20
    }
  }
}
```

### Pagination Implementation

```javascript
const getPaginatedResults = async (Model, filter, options) => {
  const { page = 1, limit = 20, sort = "-createdAt" } = options;
  const skip = (page - 1) * limit;

  const [results, total] = await Promise.all([
    Model.find(filter).sort(sort).limit(limit).skip(skip).lean(),
    Model.countDocuments(filter),
  ]);

  return {
    results,
    pagination: {
      currentPage: page,
      totalPages: Math.ceil(total / limit),
      totalProducts: total,
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1,
      limit,
    },
  };
};
```

## ‚ö° Redis Caching Strategy

### Cache All Public GET Responses

```javascript
const CACHE_DURATION = 15 * 60; // 15 minutes in seconds

// Cache key patterns
const CACHE_KEYS = {
  PRODUCT_BY_UNIQUE_ID: (uniqueId) => `product:${uniqueId}`,
  PRODUCTS_LIST: (params) => `products:${JSON.stringify(params)}`,
  PRODUCT_CATEGORIES: () => "categories:list",
};

// Cache implementation example
const getProductWithCache = async (uniqueId) => {
  const cacheKey = CACHE_KEYS.PRODUCT_BY_UNIQUE_ID(uniqueId);

  // Try cache first
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }

  // Fetch from database
  const product = await Product.findOne({ uniqueId, status: "active" }).lean();

  // Cache result
  if (product) {
    await redis.setex(cacheKey, CACHE_DURATION, JSON.stringify(product));
  }

  return product;
};
```

### Cache Invalidation Rules

**Invalidate cache on data mutations:**

```javascript
// After POST/PUT/DELETE operations
const invalidateProductCache = async (uniqueId) => {
  const keys = [
    CACHE_KEYS.PRODUCT_BY_UNIQUE_ID(uniqueId),
    "products:*", // Invalidate all product list caches
    CACHE_KEYS.PRODUCT_CATEGORIES(),
  ];

  await redis.del(...keys);
};
```

## üìÅ File Storage Guidelines

### Cloudflare R2 Integration

```javascript
// File upload structure
const uploadProductImage = async (productId, file, imageType = "gallery") => {
  const timestamp = Date.now();
  const fileName = `products/${productId}/images/${imageType}_${timestamp}.${file.extension}`;

  // Upload to R2
  const result = await r2Client.upload(fileName, file.buffer);

  // Return public URL
  return `https://${process.env.CLOUDFLARE_R2_PUBLIC_URL}/${fileName}`;
};

// File organization
// products/{productId}/images/main_{timestamp}.jpg
// products/{productId}/images/gallery_{timestamp}_{index}.jpg
// products/{productId}/files/spec_{productId}_{timestamp}.pdf
```

### File Response Format

```javascript
{
  success: true,
  message: "Files uploaded successfully.",
  data: {
    uploadedImages: [
      "https://r2-domain.com/products/TEX001/images/main_1699876543.jpg"
    ],
    product: {
      _id: "...",
      images: {
        main: "https://r2-domain.com/products/TEX001/images/main_1699876543.jpg",
        gallery: ["https://r2-domain.com/products/TEX001/images/gallery_1699876544.jpg"]
      }
    }
  }
}
```

## üî¢ Auto-Generation Patterns

### Document Number Generation

```javascript
// Enquiry numbers: ENQ-YYYY-XXX
const generateEnquiryNo = async () => {
  const year = new Date().getFullYear();
  const count = await Enquiry.countDocuments({
    createdAt: {
      $gte: new Date(year, 0, 1),
      $lt: new Date(year + 1, 0, 1),
    },
  });

  return `ENQ-${year}-${String(count + 1).padStart(3, "0")}`;
};

// Quotation numbers: QTN-YYYY-XXX
const generateQuotationNo = async () => {
  const year = new Date().getFullYear();
  const count = await Quotation.countDocuments({
    createdAt: {
      $gte: new Date(year, 0, 1),
      $lt: new Date(year + 1, 0, 1),
    },
  });

  return `QTN-${year}-${String(count + 1).padStart(3, "0")}`;
};
```

## üèóÔ∏è Code Organization

### Controller Size Limits

- **Maximum 150 lines per controller function**
- **Move complex logic to `/services` folder**
- **Use dependency injection for services**

### Service Layer Example

```javascript
// /services/ProductService.js
class ProductService {
  /**
   * Create a new product with auto-generated uniqueId
   * @param {Object} productData - Product data from request
   * @param {String} userId - ID of user creating the product
   * @returns {Object} Created product
   */
  static async createProduct(productData, userId) {
    // Generate uniqueId
    productData.uniqueId = generateUniqueId(
      productData.name,
      productData.category
    );
    productData.createdBy = userId;
    productData.updatedBy = userId;

    // Create product
    const product = new Product(productData);
    await product.save();

    // Populate references
    await product.populate("createdBy", "name email");

    return product;
  }
}
```

### JSDoc Documentation

**REQUIRED for all controller functions:**

```javascript
/**
 * Get all active products with filtering and pagination
 * @route GET /api/public/products
 * @param {Request} req - Express request object
 * @param {Response} res - Express response object
 * @returns {Promise<void>} JSON response with products list
 * @example
 * // GET /api/public/products?page=1&limit=12&category=Fabric
 * // Returns: { success: true, message: "Products retrieved successfully.", data: { products: [...], pagination: {...} } }
 */
const getPublicProducts = async (req, res) => {
  // Implementation...
};
```

## ‚ö†Ô∏è Error Handling

### Central Error Handler

```javascript
// middleware/errorHandler.js
const errorHandler = (err, req, res, next) => {
  let statusCode = err.statusCode || 500;
  let message = err.message || "Internal Server Error";
  let errors = [];

  // Mongoose validation error
  if (err.name === "ValidationError") {
    statusCode = 400;
    message = "Validation Error";
    errors = Object.values(err.errors).map((val) => val.message);
  }

  // Mongoose duplicate key error
  if (err.code === 11000) {
    statusCode = 400;
    message = "Duplicate field value";
    errors = [
      `Duplicate value for field: ${Object.keys(err.keyValue).join(", ")}`,
    ];
  }

  res.status(statusCode).json({
    success: false,
    message,
    errors: errors.length > 0 ? errors : [message],
  });
};
```

## üìÖ Timestamp Formatting

**ALWAYS use ISO8601 format:**

```javascript
// Correct timestamp format
createdAt: new Date().toISOString(); // "2024-11-14T10:30:00.000Z"

// In responses, ensure consistent formatting
const formatResponse = (data) => ({
  ...data,
  createdAt: data.createdAt.toISOString(),
  updatedAt: data.updatedAt.toISOString(),
});
```

## üé® Code Style Guidelines

### ES Modules Syntax

```javascript
// Use ES6+ import/export syntax
import express from "express";
import { ProductService } from "../services/ProductService.js";

// Export default for single exports
export default ProductController;

// Named exports for multiple exports
export { ProductController, ProductService };
```

### Async/Await Pattern

```javascript
// ALWAYS use try-catch with async/await
const createProduct = async (req, res, next) => {
  try {
    const product = await ProductService.createProduct(req.body, req.user._id);

    res.status(201).json({
      success: true,
      message: "Product created successfully.",
      data: { product },
    });
  } catch (error) {
    next(error); // Pass to error handler
  }
};
```

## üîç Development Checklist

Before implementing any endpoint:

- [ ] Check API Contract v3.0 for exact specifications
- [ ] Implement proper authentication/authorization
- [ ] Add Redis caching for GET endpoints
- [ ] Use consistent response structure
- [ ] Add JSDoc documentation
- [ ] Implement proper error handling
- [ ] Add cache invalidation for mutations
- [ ] Use .lean() for public queries
- [ ] Populate references correctly
- [ ] Follow pagination standards
- [ ] Generate SEO-friendly uniqueIds
- [ ] Exclude sensitive fields
- [ ] Use ISO8601 timestamps
- [ ] Keep controllers under 150 lines
- [ ] Add inline comments for complex logic

---

**Remember:** These guidelines ensure consistency, performance, and maintainability across the Shop Texxolution backend. Always refer to this document when implementing new features or modifying existing code.
